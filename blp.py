# coding=utf-8
# 
# Look into XML trade file generated by Bloomberg, then:
# 
# 1. Extract trades of the Quant fund.
# 2. Extract everything else (trades, trade cancellations) into a new file.
# 



import xml.etree.ElementTree as ET
from blp_trade.utility import get_current_path, get_input_directory, \
								get_portfolio_id
from blp_trade.db import tradeInDB, deletionInDB
from os.path import join
from datetime import datetime
from functools import reduce
import logging
logger = logging.getLogger(__name__)



class KeyValueNotFound(Exception):
	pass



def extractTradesToXML(inputFile, outputFile):
	"""
	[String] input file, [String] output file => extract Trades with the right
	portfolio id and write those trades to the output file in XML format.

	When extractTradesToXML() is called multiple times in a day, trades in its
	output XML files won't overlap because it saves key values of trades extracted
	to a key value file.	  
	"""
	logger.info('extractTradesToXML(): input {0}'.format(inputFile))
	writeXMLFile(
		filterTrades(
			addRemoveHeader(
				fileToLines(
					inputFile
				)
			)
			, loadKeys()
		)
		, outputFile
	)



def extractOtherToXML(inputFile, outputFile):
	"""
	[String] input file, [String] output file => extract everything except 
	trades with the right portfolio id and write to the output file in XML 
	format.
	"""
	logger.info('extractOtherToXML(): input {0}'.format(inputFile))
	writeXMLFile(
		inverseFilterTrades(
			addRemoveHeader(
				fileToLines(
					inputFile
				)
			)
		)
		, outputFile
	)



def fileToLines(file):
	"""
	[String] file => [List] lines

	read a text file and return its content as list of lines (String).
	"""
	with open(file, 'r') as f:
		return [line for line in f]



def addRemoveHeader(lines):
	"""
	[List] lines => [List] lines after taking out Geneva headers

	There are two possibilities of the XML file to process:

	1) The root elements <GenevaLoader> and <TransactionRecords> are missing,
		only child elements are there, like:

		<Sell_New>
		...
		</Sell_New>
		<Buy_New>
		...
		<Buy_New>


	2) The root elements are there, like:
	<GenevaLoader xmlns=...>
		<TransactionRecords>
			... child elements
		</TransactionRecords>
	</GenevaLoader>

	If it is case (1), then we use the <TransactionRecords> tag to wrap all the
	content; If it is case (2), then we remove <GenevaLoader> header. In either
	case, we end up with an XML document with <TransactionRecords> as the root
	element.
	"""
	if lines[0].startswith('<GenevaLoader'):
		return lines[1:len(lines)-1]
	else:
		return ['<TransactionRecords>'] + lines + ['</TransactionRecords>']



def filterTrades(lines):
	"""
	[List] lines => A tuple consisting of the below:
		[byte string] XML content (string encoded with utf-8)
		[List] trade key values (String) of trades extracted
		[List] deleted trade key values (String) of trade deletions extracted

	The function searches for trades with the right portfolio id, as well
	as deletions of previous trades and extract those out, then create an
	XML string consisting of the above.

	The format of the input XML is as below:

	<TransactionRecords>
	... transaction records as child elements
	</TransactionRecords>

	A trade takes the following form:

	<XXX_New>
		<Portfolio>XXX</Portfolio>
		...
		<KeyValue>XXX</KeyValue>
	</XXX_New>

	Where "XXX_New" is the trade type, such as "Buy_New", "Sell_New", etc. 
	
	A trade deletion takes the following form:

	<XXX_delete>
		<KeyValue>XXXXXXX</KeyValue>
	</XXX_delete>

	Where "XXX" is the trade type, such as "Sell", "CoverShort", etc.
	"""
	def isTrade(transaction):
		""" tell whether a transaction node is a trade of portfolio 40006 """
		# if transaction.tag in ['Buy_New', 'Sell_New', 'SellShort_New', \
		# 	'CoverShort_New'] and transaction.find('Portfolio') and \
		# 	isRightPortfolio(transaction.find('Portfolio').text):
		if transaction.tag in ['Buy_New', 'Sell_New', 'SellShort_New', \
			'CoverShort_New'] and isRightPortfolio(transaction):
			return True
		else:
			return False


	def isDeletion(transaction):
		""" tell whether a transaction node is a trade deletion """
		if transaction.tag in ['Buy_Delete', 'Sell_Delete', 'SellShort_Delete', 'CoverShort_Delete']:
			return True
		else:
			return False


	root = ET.fromstringlist(lines)
	# for transaction in root:
	# 	print(transaction.tag)

	# filter(tradeTransferred, filter(trade, ...))
	# filter(deletionTransferred, filter(deletion, ...))

	def buildResult(result, transaction):
		newRoot, tradeKeys, deletionKeys = result
		if isTrade(transaction) and not tradeInDB(transaction.tag):
			newRoot.append(transaction)
			tradeKeys.append(transaction.find('KeyValue').text)
		elif isDeletion(transaction) and not deletionInDB(transaction.tag) \
			and forPreviousTrades(tradeKeys, transaction):
			newRoot.append(transaction)
			deletionKeys.append(transaction.find('KeyValue').text)

		return (newRoot, tradeKeys, deletionKeys)


	return reduce(buildResult, root, (ET.Element('TransactionRecords'), [], []))



def inverseFilterTrades(lines):
	"""
	[List] lines => [bytes] XML content (string encoded with utf-8)

	It's the opposite of filterTrades(), it keeps out those trades with the
	right portfolio id, the rest will be 
	"""
	root = ET.fromstringlist(lines)
	newRoot = ET.Element('TransactionRecords')
	for transaction in root:
		portfolio = transaction.find('Portfolio')
		if portfolio == None or not isRightPortfolio(portfolio.text):
			newRoot.append(transaction)

	return ET.tostring(newRoot, encoding='utf-8', method='xml', short_empty_elements=True)



def writeXMLFile(content, filename='output.xml'):
	"""
	[bytes] (utf-8 encoded byte string )content => create a text file.

	take the content (bytes encoded as utf-8), prepand and append Geneva XML header 
	to it, then	write to a text file, return the file's full path.
	"""
	with open(filename, 'wb') as file:
		file.write(
			b'<GenevaLoader xmlns="http://www.advent.com/SchemaRevLevel758/Geneva" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.advent.com/SchemaRevLevel758/Geneva masterschema.xsd">\n' + \
			content + \
			b'\n</GenevaLoader>')



def isRightPortfolio(transaction):
	"""
	[ET node] transaction => [Bool] yesno

	the transaction looks like follows:

	<SellShort_New>
		<Portfolio>40006-C</Portfolio>
		...
	</SellShort_New>

	We need to find out whether the "Portfolio" matches what we look for.
	"""
	portfolio = transaction.find('Portfolio')
	if portfolio != None and portfolio.text.startswith(get_portfolio_id()):
		return True
	else:
		return False



def forPreviousTrades(tradeKeys, transaction):
	"""
	[List] tradeKeys, [ET node] transaction => [Bool] yesno

	the transaction looks like follows:

	<SellShort_Delete>
		<KeyValue>123235</KeyValue>
	</SellShort_Delete>

	Determine whether the transaction's keyValue is in tradeKeys or in database.
	"""
	keyValue = transaction.find('KeyValue')
	if keyValue != None and (keyValue.text in tradeKeys or deletionInDB(keyValue.text)):
		return True
	else:
		return False



def saveKeys(keyList):
	"""
	[List] key list => write the list of keys (string) to a text file.
	"""
	if keyList == []:
		return

	with open(getFilename(), 'a') as textFile:
		for key in keyList:
			print('{0}'.format(key), file=textFile)



def loadKeys():
	"""
	Read a text file => [List] keys
	"""
	try:
		textFile = open(getFilename(), 'r')
		return [line.strip() for line in textFile]
	except FileNotFoundError:
		return []



def getFilename():
	"""
	return the text file name for today.

	Text files storing keys are stored and named as:

	keyFiles/keys_yyyymmdd.txt
	"""
	return join(get_current_path(), 'keyFiles', 
				'keys_' + datetime.today().strftime('%Y%m%d') + '.txt')



def deleteKeyFile():
	"""
	Delete the key file keys_yyyymmdd.txt (today's date) in the keyFiles folder.

	For testing purpose only.
	"""
	import os
	try:
		os.remove(getFilename())
	except FileNotFoundError:
		pass	# ignore



if __name__ == '__main__':
	import logging.config
	logging.config.fileConfig('logging.config', disable_existing_loggers=False)

	import argparse
	parser = argparse.ArgumentParser()
	parser.add_argument('file', metavar='input file', type=str)
	args = parser.parse_args()

	newRoot, tradeKeys, deletionKeys = filterTrades(addRemoveHeader(fileToLines(join(get_current_path(), args.file))))
	writeXMLFile(
		ET.tostring(newRoot, encoding='utf-8', method='xml', short_empty_elements=True)
		, 'output_' + args.file
	)


	# extractTradesToXML(
	# 	join(get_input_directory()
	# 		, 'TransToGeneva20181031_morning.xml'
	# 	)
	# 	, 'output.xml'
	# )

	# extractTradesToXML(
	# 	join(get_input_directory()
	# 		, 'TransToGeneva20181031_night.xml'
	# 	)
	# 	, 'output2.xml'
	# )

	# extractOtherToXML(
	# 	join(get_input_directory()
	# 		, 'TransToGeneva20181031_night.xml'
	# 	)
	# 	, 'output3.xml'
	# )

	# deleteKeyFile()		# so that subsequent runs can still generate output