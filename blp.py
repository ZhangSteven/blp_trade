# coding=utf-8
# 
# Look into XML trade file generated by Bloomberg, then:
# 
# 1. Extract trades of the Quant fund.
# 2. Extract everything else (trades, trade cancellations) into a new file.
# 



import xml.etree.ElementTree as ET
import logging
logger = logging.getLogger(__name__)



def fileToLines(file):
	"""
	[String] file => [List] lines

	read a text file and return its content as list of lines (String).
	"""
	with open(file, 'r') as f:
		return [line for line in f]



def stripGenevaHeader(lines):
	"""
	[List] lines => [List] lines after taking out Geneva headers

	if the lines start with <GenevaLoader> and end with <GenevaLoader>, as below:

	<GenevaLoader xmlns=...>
	... content ...
	</GenevaLoader>

	Then strip the first and the last line.
	"""
	if lines[0].startswith('<GenevaLoader'):
		return lines[1:len(lines)-1]
	else:
		return lines



def filterQuantTrades(lines):
	"""
	[List] lines => [bytes] XML content (string encoded with utf-8)

	Parse the lines as XML, as below:

	<TransactionRecords>
	... transaction records as child elements
	</TransactionRecords>

	only keep child elements relating to Quantitative funds.

	Buggy: this way of removing documents is unsafe. When elements to be
	removed is the just last one, it looks OK. But if it is in the middle,
	then it stops working.
	"""
	root = ET.fromstringlist(lines)
	newRoot = ET.Element('TransactionRecords')
	for transaction in root:
		portfolio = transaction.find('Portfolio')
		if portfolio != None and isRightPortfolio(portfolio.text):
			newRoot.append(transaction)

	return ET.tostring(newRoot, encoding='utf-8', method='xml', short_empty_elements=True)



def removeQuantTrades(lines):
	"""
	[List] lines => [bytes] XML content (string encoded with utf-8)

	Parse the lines as XML, as below:

	<TransactionRecords>
	... transaction records as child elements
	</TransactionRecords>

	It's the opposite of filterQuantTrades(), only keep child elements 
	not relating to Quantitative funds.
	"""
	root = ET.fromstringlist(lines)
	newRoot = ET.Element('TransactionRecords')
	for transaction in root:
		portfolio = transaction.find('Portfolio')
		if portfolio == None or not isRightPortfolio(portfolio.text):
			newRoot.append(transaction)

	return ET.tostring(newRoot, encoding='utf-8', method='xml', short_empty_elements=True)



def writeXMLFile(content, filename='output.xml'):
	"""
	[byte string] content => create a text file.

	take the content (bytes encoded as utf-8), prepand and append Geneva XML header 
	to it, then	write to a text file, return the file's full path.
	"""
	with open(filename, 'wb') as file:
		file.write(
			b'<GenevaLoader xmlns="http://www.advent.com/SchemaRevLevel758/Geneva" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.advent.com/SchemaRevLevel758/Geneva masterschema.xsd">\n' + \
			content + \
			b'</GenevaLoader>')




def isRightPortfolio(portId):
	"""
	[String] portId => [Bool] yesno

	Determine whether the portfolio id is of interest.
	"""
	if portId.startswith('40006'):
		return True
	else:
		return False




if __name__ == '__main__':
	from blp_trade.utility import get_current_path
	import logging.config
	logging.config.fileConfig('logging.config', disable_existing_loggers=False)

	from os.path import join
	# fileToTransactions(join(get_current_path(), 'samples', 'TransToGeneva20161223.xml'))
	# fileToTransactions(join(get_current_path(), 'samples', 'TransToGeneva20161223_noheader.xml'))

	writeXMLFile(filterQuantTrades(stripGenevaHeader(fileToLines(
		join(get_current_path(), 'samples', '40006_simple_noheader.xml')))))

	writeXMLFile(removeQuantTrades(stripGenevaHeader(fileToLines(
		join(get_current_path(), 'samples', '40006_simple.xml')))),
		'output2.xml')