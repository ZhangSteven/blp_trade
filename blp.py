# coding=utf-8
# 
# Look into XML trade file generated by Bloomberg, then:
# 
# 1. Extract trades of the Quant fund.
# 2. Extract everything else (trades, trade cancellations) into a new file.
# 



import xml.etree.ElementTree as ET
from blp_trade.utility import get_current_path, get_input_directory, \
								get_portfolio_id
from os.path import join
from datetime import datetime
import logging
logger = logging.getLogger(__name__)



class KeyValueNotFound(Exception):
	pass



def extractTradesToXML(inputFile, outputFile):
	"""
	[String] input file, [String] output file => extract Trades with the right
	portfolio id and write those trades to the output file in XML format.

	When extractTradesToXML() is called multiple times in a day, trades in its
	output XML files won't overlap because it saves key values of trades extracted
	to a key value file.	  
	"""
	logger.info('extractTradesToXML(): input {0}'.format(inputFile))
	writeXMLFile(
		filterTrades(
			addRemoveHeader(
				fileToLines(
					inputFile
				)
			)
			, loadKeys()
		)
		, outputFile
	)



def extractOtherToXML(inputFile, outputFile):
	"""
	[String] input file, [String] output file => extract everything except 
	trades with the right portfolio id and write to the output file in XML 
	format.
	"""
	logger.info('extractOtherToXML(): input {0}'.format(inputFile))
	writeXMLFile(
		inverseFilterTrades(
			addRemoveHeader(
				fileToLines(
					inputFile
				)
			)
		)
		, outputFile
	)



def fileToLines(file):
	"""
	[String] file => [List] lines

	read a text file and return its content as list of lines (String).
	"""
	with open(file, 'r') as f:
		return [line for line in f]



def addRemoveHeader(lines):
	"""
	[List] lines => [List] lines after taking out Geneva headers

	There are two possibilities of the XML file to process:

	1) The root elements <GenevaLoader> and <TransactionRecords> are missing,
		only child elements are there, like:

		<Sell_New>
		...
		</Sell_New>
		<Buy_New>
		...
		<Buy_New>


	2) The root elements are there, like:
	<GenevaLoader xmlns=...>
		<TransactionRecords>
			... child elements
		</TransactionRecords>
	</GenevaLoader>

	If it is case (1), then we use the <TransactionRecords> tag to wrap all the
	content; If it is case (2), then we remove <GenevaLoader> header. In either
	case, we end up with an XML document with <TransactionRecords> as the root
	element.
	"""
	if lines[0].startswith('<GenevaLoader'):
		return lines[1:len(lines)-1]
	else:
		return ['<TransactionRecords>'] + lines + ['</TransactionRecords>']



def filterTrades(lines):
	"""
	[List] lines => A tuple consisting of the below:
		[byte string] XML content (string encoded with utf-8)
		[List] key value (String) of trades extracted
		[List] key value (String) of trade deletions extracted

	The function searches for trades with the right portfolio id, as well
	as deletions of previous trades and extract those out, then create an
	XML string consisting of the above.

	The format of the input XML is as below:

	<TransactionRecords>
	... transaction records as child elements
	</TransactionRecords>

	A trade takes the following form:

	<XXX_New>
		<Portfolio>XXX</Portfolio>
		...
		<KeyValue>XXX</KeyValue>
	</XXX_New>

	Where "XXX_New" is the trade type, such as "Buy_New", "Sell_New", etc. 
	
	A trade deletion takes the following form:

	<XXX_delete>
		<KeyValue>XXXXXXX</KeyValue>
	</XXX_delete>

	Where "XXX" is the trade type, such as "Sell", "CoverShort", etc.
	"""
	root = ET.fromstringlist(lines)
	newRoot = ET.Element('TransactionRecords')
	keyList = []
	for transaction in root:
		portfolio = transaction.find('Portfolio')
		if portfolio != None and isRightPortfolio(portfolio.text):
			try:
				keyValue = transaction.find('KeyValue').text
				if not keyValue in skipKeys:
					keyList.append(keyValue)
					newRoot.append(transaction)
			except:
				raise KeyValueNotFound()

	# save the transaction keys to somewhere (text file)
	saveKeys(keyList)

	# generate XML as an utf-8 encoded byte string
	return ET.tostring(newRoot, encoding='utf-8', method='xml', short_empty_elements=True)


	Maybe we consider this:

	filter(tradeTransferred, filter(trade, ...))

	filter(deletionTransferred, filter(deletion, ...))

	




def inverseFilterTrades(lines):
	"""
	[List] lines => [bytes] XML content (string encoded with utf-8)

	It's the opposite of filterTrades(), it keeps out those trades with the
	right portfolio id, the rest will be 
	"""
	root = ET.fromstringlist(lines)
	newRoot = ET.Element('TransactionRecords')
	for transaction in root:
		portfolio = transaction.find('Portfolio')
		if portfolio == None or not isRightPortfolio(portfolio.text):
			newRoot.append(transaction)

	return ET.tostring(newRoot, encoding='utf-8', method='xml', short_empty_elements=True)



def writeXMLFile(content, filename='output.xml'):
	"""
	[bytes] (utf-8 encoded byte string )content => create a text file.

	take the content (bytes encoded as utf-8), prepand and append Geneva XML header 
	to it, then	write to a text file, return the file's full path.
	"""
	with open(filename, 'wb') as file:
		file.write(
			b'<GenevaLoader xmlns="http://www.advent.com/SchemaRevLevel758/Geneva" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.advent.com/SchemaRevLevel758/Geneva masterschema.xsd">\n' + \
			content + \
			b'\n</GenevaLoader>')



def isRightPortfolio(portId):
	"""
	[String] portId => [Bool] yesno

	Determine whether the portfolio id is of interest.
	"""
	if portId.startswith(get_portfolio_id()):
		return True
	else:
		return False



def saveKeys(keyList):
	"""
	[List] key list => write the list of keys (string) to a text file.
	"""
	if keyList == []:
		return

	with open(getFilename(), 'a') as textFile:
		for key in keyList:
			print('{0}'.format(key), file=textFile)



def loadKeys():
	"""
	Read a text file => [List] keys
	"""
	try:
		textFile = open(getFilename(), 'r')
		return [line.strip() for line in textFile]
	except FileNotFoundError:
		return []



def getFilename():
	"""
	return the text file name for today.

	Text files storing keys are stored and named as:

	keyFiles/keys_yyyymmdd.txt
	"""
	return join(get_current_path(), 'keyFiles', 
				'keys_' + datetime.today().strftime('%Y%m%d') + '.txt')



def deleteKeyFile():
	"""
	Delete the key file keys_yyyymmdd.txt (today's date) in the keyFiles folder.

	For testing purpose only.
	"""
	import os
	try:
		os.remove(getFilename())
	except FileNotFoundError:
		pass	# ignore



if __name__ == '__main__':
	import logging.config
	logging.config.fileConfig('logging.config', disable_existing_loggers=False)

	extractTradesToXML(
		join(get_input_directory()
			, 'TransToGeneva20181031_morning.xml'
		)
		, 'output.xml'
	)

	extractTradesToXML(
		join(get_input_directory()
			, 'TransToGeneva20181031_night.xml'
		)
		, 'output2.xml'
	)

	extractOtherToXML(
		join(get_input_directory()
			, 'TransToGeneva20181031_night.xml'
		)
		, 'output3.xml'
	)

	deleteKeyFile()		# so that subsequent runs can still generate output